---
title: "simulation2figure_combined"
output: html_document
---

```{r setup, include=FALSE,cache=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SKAT)
library(bindata)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(expm)
library(KATSP)
library(ggpubr)
library(grid)
library(mvtnorm)

theme_set(theme_cowplot())
mytheme = list(
  theme_classic()+
    theme(panel.background = element_blank(),strip.background = element_rect(colour=NA, fill=NA),panel.border = element_rect(fill = NA, color = "black"),
          legend.position="none", )
)

beta1list <- list(
  c(-0.9, -0.75, -0.5, -0.25, -0.1, -0.9, -0.75, -0.5, -0.25, -0.1,
    -0.9, -0.75, -0.5, -0.25, -0.1, -0.9, -0.75, -0.5, -0.25, -0.1,
    -0.9, -0.75, -0.5, -0.25, -0.1),
  c(-1.5, -1.25, -1, -0.75, -0.5, -1.5, -1.25, -1, -0.75, -0.5,
    -1.5, -1.25, -1, -0.75, -0.5, -1.5, -1.25, -1, -0.75, -0.5,
    -1.5, -1.25, -1, -0.75, -0.5),
  c(-3, -2.5, -2, -1.5, -1, -3, -2.5, -2, -1.5, -1,
    -3, -2.5, -2, -1.5, -1, -3, -2.5, -2, -1.5, -1,
    -3, -2.5, -2, -1.5, -1)
)

beta2list <- list(
  c(rep(0.9, 5), rep(0.75, 5), rep(0.5, 5), rep(0.25, 5), rep(0.1, 5)),
  c(rep(1.5, 5), rep(1.25, 5), rep(1, 5), rep(0.75, 5), rep(0.5, 5)),
  c(rep(3, 5), rep(2.5, 5), rep(2, 5), rep(1.5, 5), rep(1, 5))
)

beta1list1<-c(-0.9,-0.75,-0.5,-0.25,-0.1, 
             -0.9,-0.75,-0.5,-0.25,-0.1,
             -0.9,-0.75,-0.5,-0.25,-0.1,
             -0.9,-0.75,-0.5,-0.25,-0.1,
             -0.9,-0.75,-0.5,-0.25,-0.1)
beta2list1<-c( rep(0.9,5),rep(0.75,5),rep(0.5,5),rep(0.25,5),rep(0.1,5))

beta1list11<-c(-0.5,-0.4,-0.3,-0.2,-0.1, 
             -0.5,-0.4,-0.3,-0.2,-0.1,
             -0.5,-0.4,-0.3,-0.2,-0.1,
             -0.5,-0.4,-0.3,-0.2,-0.1,
             -0.5,-0.4,-0.3,-0.2,-0.1)
beta2list11<-c( rep(0.5,5),rep(0.4,5),rep(0.3,5),rep(0.2,5),rep(0.1,5))


beta1list2<-c(-1.5,-1.25,-1,-0.75,-0.5,
             -1.5,-1.25,-1,-0.75,-0.5,
             -1.5,-1.25,-1,-0.75,-0.5,
             -1.5,-1.25,-1,-0.75,-0.5,
             -1.5,-1.25,-1,-0.75,-0.5)
beta2list2<-c( rep(1.5,5),rep(1.25,5),rep(1,5),rep(0.75,5),rep(0.5,5))

beta1list3<-c(-3,-2.5,-2,-1.5,-1, 
             -3,-2.5,-2,-1.5,-1, 
             -3,-2.5,-2,-1.5,-1,
             -3,-2.5,-2,-1.5,-1,
             -3,-2.5,-2,-1.5,-1)
beta2list3<-c( rep(3,5),rep(2.5,5),rep(2,5),rep(1.5,5),rep(1,5))

lee<-function(c){ 
      muq=c[1]
      sigmaq=sqrt(2*c[2])
      s1=c[3]/c[2]^(3/2)
      s2=c[4]/c[2]^2
      if (s1^2>s2) 
      {a=1/(s1-sqrt(s1^2-s2))
      delta= (s2*a^4-a^2)/2
      }else 
      {a=1/sqrt(s2)
      delta=0}
      l=a^2-2*delta
      mux=l+delta
      sigmax=sqrt(2)*sqrt(l+2*delta)  
      return(list(l=l,delta=delta,sigmaq=sigmaq,muq=muq,mux=mux,sigmax=sigmax))
}

powerC_derive<-function(k,n,alpha,p,list1,list2){
  power<-c()
  for (ii in 1:length(list1)){
    beta<-c(rep(0,k-2),list1[ii], list2[ii])
    #based on derivation
    A<-diag(2*p*(1-p),nrow=k,ncol=k)
    B<-diag((2*n*p*(1-3*p+4*p^2-2*p^3)+4*n^2*(p^2-2*p^3+p^4))*beta^2/n^2,nrow=k,ncol=k)
   
 
    c1<-rep(0,4)
    c2<-rep(0,4)
    c_a<-rep(0,4)
    
  A2<-A %*% A
  A3<-A2 %*% A
  
  c1[1] = sum(diag(A)) * n
  c1[2] = sum(A *t(A)) * n^2
  c1[3] = sum(A2 * t(A) ) * n^3
  c1[4] = sum(A2 * t(A2)) * n^4
  
  c2[1] = sum(diag(B)) * n^2
  c2[2] = 2 * sum(A * t(B)) * n^3
  c2[3] = 3 * sum(A2 * t(B)) * n^4
  c2[4] = 4 * sum(A3* t(B)) * n^5
    
    for(mm in 1:4){
      c_a[mm]<-c1[mm] + c2[mm]
    }

    #under null
    null<-lee(c1)
    quantile<-qchisq(1-alpha, df = null$l, ncp = null$delta)
    qc=(quantile-null$mux)*null$sigmaq/null$sigmax+null$muq
    #under alternative
    alt<-lee(c_a)
    temp<-(qc-alt$muq)*alt$sigmax/alt$sigmaq+alt$mux
    power[ii]<-pchisq(temp,df=alt$l,ncp=alt$delta,lower.tail = FALSE)
  }
  return(power)
}

powerC_deriveCor_old<-function(k,n,alpha,p,rho,list1,list2) {
  power<-c()
   for (ii in 1:25){
    beta<-c(rep(0,k-2),list1[ii], list2[ii])
 
a=(rho*2*p*(1-p))^2
c=rho*(2*p*(1-p))^2
e=4*p^2*(1-p)^2
g=2*p*(1-p)

#condition on 0
p0_0=(1-p+rho*p)^2
p1_0=2*p*(1-rho)*(1-p+rho*p)
p2_0=(p-rho*p)^2
p2_0+p1_0+p0_0
#condition on 1
p0_1=(1-p-rho+rho*p)*(1-p+rho*p)
p1_1=(p+rho-rho*p)*(1-p+rho*p)+(p-p*rho)*(1-p-rho+p*rho)
p2_1=(p+rho-rho*p)*(p-p*rho)
p0_1+p1_1+p2_1
#condition on 2
p0_2=(1-p-rho+rho*p)^2
p1_2=2*(p+rho-rho*p)*(1-p-rho+p*rho)
p2_2=(p+rho-rho*p)^2
p0_2+p1_2+p2_2

p0=(1-p)^2
p1=2*p*(1-p)
p2=p^2

p00=p0_0*p0
p11=p1_1*p1
p22=p2_2*p2
p20=p2_0*p0
p02=p0_2*p2
p12=p1_2*p2
p21=p2_1*p1
p10=p1_0*p0
p01=p0_1*p1


g0=0-2*p
g1=1-2*p
g2=2-2*p


d=e_g2g2=(g0^2*p0*(g0^2*p0_0+g1^2*p1_0+g2^2*p2_0)
          +g1^2*p1*(g0^2*p0_1+g1^2*p1_1+g2^2*p2_1)
          +g2^2*p2*(g0^2*p0_2+g1^2*p1_2+g2^2*p2_2))

#d <- 2 * (1 - 2*p)^2 * rho * p * (1 - p) + (4 + 4*rho^2) * p^2 * (1 - p)^2
f=e_g1g3=(g0^3*p0*(g0*p0_0+g1*p1_0+g2*p2_0)
          +g1^3*p1*(g0*p0_1+g1*p1_1+g2*p2_1)
          +g2^3*p2*(g0*p0_2+g1*p1_2+g2*p2_2))
 b=e_g2g1g1=(g0^2*g0*p00+g0^2*g1*p01+g0^2*g2*p02)*(g0*p0_0+g1*p1_0+g2*p2_0)+ (g1^2*g0*p10+g1^2*g1*p11+g1^2*g2*p12)*(g0*p0_1+g1*p1_1+g2*p2_1)+(g2^2*g0*p20+g2^2*g1*p21+g2^2*g2*p22)*(g0*p0_2+g1*p1_2+g2*p2_2)
 
set.seed(100) 
margprob <- c(rep(p, 4))  
bincorr <- (1 - rho) * diag(4) + rho  
commonprob<-bincorr2commonprob(margprob, bincorr)
sigma<-commonprob2sigma(commonprob)
C <- rmvbin(n,margprob=diag(commonprob),sigma=sigma)
C1 <- C[, 1]
C2 <- C[, 2]
C3 <- C[, 3]
C4 <- C[, 4]
D <- rmvbin(n,margprob=diag(commonprob),sigma=sigma)
D1 <- D[, 1]
D2 <- D[, 2]
D3 <- D[, 3]
D4 <- D[, 4]

G1=G11 <- C1 + D1
G2=G12 <- C2 + D2
G3=G13 <- C3 + D3
G4=G14 <- C4 + D4
GG1=G1-2*p
GG2=G2-2*p
GG3=G3-2*p
GG4=G4-2*p


h=mean(GG1*GG2*GG3*GG4)


A <- matrix(rho*2*p*(1-p), nrow = k, ncol = k)
diag(A) <-2*p*(1-p)
B_diag <- function(x) {
  term1 <- n * (g + (n - 1) * e) * beta[x]^2
  term2 <- n * (d + (n - 1) * a) * sum(beta[-x]^2)
  term3 <- 2 * n * (f + (n - 1) * c) * sum(beta[-x] * beta[x])
  term4 <-  n * (b + (n - 1) * a) * (sum(outer(beta[-x], beta[-x], "*"))-sum(beta[-x]^2))

  result <- (term1 + term2 + term3 + term4 )/n^2
  return(result)
}

B_offdiag <- function(x,y) {
  term1 <- (n * f + n * (n - 1) * c) * (beta[x]^2 + beta[y]^2)
  term2 <- (n * b + n * (n - 1) * a) * sum(beta[-c(x, y)]^2)
  term3 <- (2*n*d+n * (n - 1) * ( a + e)) * beta[x] * beta[y]
  term4 <- (2*n*b+n * (n - 1) * (a + c)) * sum(outer(beta[-c(x, y)], beta[x], "*"),outer(beta[-c(x, y)], beta[y], "*"))
  term5<-n*h+n*(n-1)*a*(sum(outer(beta[-c(x,y)], beta[-c(x,y)], "*"))-sum(beta[-c(x,y)]^2))
      
   result <- (term1 + term2 + term3 + term4 + term5)/n^2
   return(result)
}


B <- matrix(0, k,k)

# Calculate elements for B
for (x in 1:k) {
  for (y in 1:k) {
    if (x == y) {
      B[x, y] <- B_diag(x)
    } else {
      B[x, y] <- B_offdiag(x,y)
    }
  }
}
    suml=sumld=cnull=calt<- numeric(4)  
    
    c1<-rep(0,4)
    c2<-rep(0,4)
    c_a<-rep(0,4)
    
  A2<-A %*% A
  A3<-A2 %*% A
  
 
  c1[1] = sum(diag(A)) * n
  c1[2] = sum(A *t(A)) * n^2
  c1[3] = sum(A2 * t(A) ) * n^3
  c1[4] = sum(A2 * t(A2)) * n^4
  
  c2[1] = sum(diag(B)) * n^2
  c2[2] = 2 * sum(A * t(B)) * n^3
  c2[3] = 3 * sum(A2 * t(B)) * n^4
  c2[4] = 4 * sum(A3* t(B)) * n^5
  
    for(i in 1:4){
      c_a[i]<-c1[i] + c2[i]
    }
    #under null
    null<-lee(c1)
    q0<-qchisq(1-alpha, df = null$l, ncp = null$delta)
    qc=(q0-null$mux)*null$sigmaq/null$sigmax+null$muq
    #under alternative
    alt<-lee(c_a)
    temp<-(qc-alt$muq)*alt$sigmax/alt$sigmaq+alt$mux
    power[ii]<-pchisq(temp,df=alt$l,ncp=alt$delta,lower.tail = FALSE)
  }
  return(power)
}
powerC_deriveCor<-function(k,n,alpha,p,rho,list1,list2) {
  power<-c()
  for (ii in 1:length(list1)){
    # set effect sizes for each SNP
    beta<-c(rep(0,k-2),list1[ii], list2[ii])
   # Construct latent covariance matrix for Group 1 (A1, B1, C1, D1)
    margprob <- rep(p, 4)
    bincorr <- matrix(rho, nrow = 4, ncol = 4)
    diag(bincorr) <- 1 
    
    # Convert binary correlations to latent normal covariance
    commonprob <- bincorr2commonprob(margprob, bincorr)
    sigma <- commonprob2sigma(commonprob)
    mu <- rep(qnorm(p), 4)  # Thresholds for P(Z > 0) = p
    
    # Φ₄ (4-variate normal CDF)
    Phi4 <- pmvnorm(lower = rep(0, 4), upper = rep(Inf, 4), mean = mu, sigma = sigma)[1]
    
    # Φ₃ (3-variate normal CDF for a subset, e.g., A1, B1, C1)
    Phi3 <- pmvnorm( lower = rep(0, 3),upper = rep(Inf, 3), mean = mu[1:3],sigma = sigma[1:3, 1:3])[1]
    
    # calculate elements a to h
    
    #a=E(G11*G12*G21*G22) 
    a=(rho*2*p*(1-p))^2
    
    #b=E(G11^2*G12*G13)
    b_term1 <- 2 * (1 - 2*p) * Phi3
    b_term2 <- 2 * rho * p^3 * (1 - p)
    b_term3 <- -4 * (1 - 2*p) * rho * p^2 * (1 - p)
    b_term4 <- -2 * (1 - 2*p) * p^3
    b <- b_term1 + b_term2 + b_term3 + b_term4
    
    #c=E(G11^2*G21*G22)
    c=rho*(2*p*(1-p))^2
    
    #d=E(G11^2*G12^2)
    #d=4 * p^2 * (1 - p)^2 + 2 * rho * p * (1 - p) * (1 - 2*p)^2
    d <- 2 * (1 - 2*p)^2 * rho * p * (1 - p) + (4 + 4*rho^2) * p^2 * (1 - p)^2
    #e=E(G11^2*G21^2)
    e=4*p^2*(1-p)^2
    
    #f=E(G11^3*G12)
    f=2 * rho * p * (1 - p) * (3*p^2 - 3*p + 1)
    
    #g=E(G11^4)
    g=2*p*(1-p)
    
    #h=E(G11*G12*G13*G14)
    h_term1 <- 2 * Phi4
    h_term2 <- -8 * p * Phi3
    h_term3 <- 6 * p^4
    h_term4 <- 12 * rho * p^3 * (1 - p)
    h_term5 <- 6 * (rho * p * (1 - p))^2
    h <- h_term1 + h_term2 + h_term3 + h_term4 + h_term5

    
    # construct matrix A and B using elements a to h
    A <- matrix(rho*2*p*(1-p), nrow = k, ncol = k)
    diag(A) <-2*p*(1-p)
    B_diag <- function(x) {
      term1 <- n * (g + (n - 1) * e) * beta[x]^2
      term2 <- n * (d + (n - 1) * a) * sum(beta[-x]^2)
      term3 <- 2 * n * (f + (n - 1) * c) * sum(beta[-x] * beta[x])
      term4 <-  n * (b + (n - 1) * a) * (sum(outer(beta[-x], beta[-x], "*"))-sum(beta[-x]^2))

      result <- (term1 + term2 + term3 + term4 )/n^2
      return(result)
    }

    B_offdiag <- function(x,y) {
      term1 <- (n * f + n * (n - 1) * c) * (beta[x]^2 + beta[y]^2)
      term2 <- (n * b + n * (n - 1) * a) * sum(beta[-c(x, y)]^2)
      term3 <- (2*n*d+n * (n - 1) * ( a + e)) * beta[x] * beta[y]
      term4 <- (2*n*b+n * (n - 1) * (a + c)) * sum(outer(beta[-c(x, y)], beta[x], "*"),outer(beta[-c(x, y)], beta[y], "*"))
      term5<-n*h+n*(n-1)*a*(sum(outer(beta[-c(x,y)], beta[-c(x,y)], "*"))-sum(beta[-c(x,y)]^2))

      result <- (term1 + term2 + term3 + term4 + term5)/n^2
      return(result)
    }


    B <- matrix(0, k,k)

    for (x in 1:k) {
      for (y in 1:k) {
        if (x == y) {
          B[x, y] <- B_diag(x)
        } else {
          B[x, y] <- B_offdiag(x,y)
        }
      }
    }
    suml=sumld=cnull=calt<- numeric(4)



    A2<-A %*% A
    A3<-A2 %*% A

    c1<-rep(0,4)
    c2<-rep(0,4)
    c_a<-rep(0,4)
    c1[1] = sum(diag(A)) * n
    c1[2] = sum(A *t(A)) * n^2
    c1[3] = sum(A2 * t(A) ) * n^3
    c1[4] = sum(A2 * t(A2)) * n^4

    c2[1] = sum(diag(B)) * n^2
    c2[2] = 2 * sum(A * t(B)) * n^3
    c2[3] = 3 * sum(A2 * t(B)) * n^4
    c2[4] = 4 * sum(A3* t(B)) * n^5

    for(i in 1:4){
      c_a[i]<-c1[i] + c2[i]
    }
    #under null
    null<-lee(c1)
    q0<-qchisq(1-alpha, df = null$l, ncp = null$delta)
    qc=(q0-null$mux)*null$sigmaq/null$sigmax+null$muq
    #under alternative
    alt<-lee(c_a)
    temp<-(qc-alt$muq)*alt$sigmax/alt$sigmaq+alt$mux
    power[ii]<-pchisq(temp,df=alt$l,ncp=alt$delta,lower.tail = FALSE)
  }
  return(power)
}

powerD_derive<-function(kk,n,alpha,p,list1,list2){
power<-c()
k1=kk-1
k2=kk
alpha0=-1
pi_0=exp(alpha0)/(1+exp(alpha0))

  for (ii in 1:25){
beta<-c(rep(0,kk-2),list1[ii], list2[ii])
G <- c(0, 1, 2)
prob_G <- c((1 - p)^2, 2 * p * (1 - p), p^2)
Gc <- G - 2 * p 

genotypes <- expand.grid(Gk1 = G, Gk2 = G)
genotypes$prob_Gk1 <- prob_G[genotypes$Gk1 + 1]
genotypes$prob_Gk2 <- prob_G[genotypes$Gk2 + 1]
genotypes$prob <- genotypes$prob_Gk1 * genotypes$prob_Gk2
genotypes$Gck1 <- genotypes$Gk1 - 2 * p
genotypes$Gck2 <- genotypes$Gk2 - 2 * p

sigma_prime <- function(x) {
  exp(x) / (1 + exp(x))^2
}

genotypes$eta <- beta[k1] * genotypes$Gck1 + beta[k2] * genotypes$Gck2 + alpha0
genotypes$v1 <- sigma_prime(genotypes$eta)
genotypes$pi_i <- exp(genotypes$eta) / (1 + exp(genotypes$eta))
#pi_0 <- sum(genotypes$pi_i * genotypes$prob)
genotypes$mu_beta <- genotypes$pi_i - pi_0
E_v1 <- sum(genotypes$v1 * genotypes$prob)
E_mu_beta2 <- sum(genotypes$mu_beta^2 * genotypes$prob)
Var_G <- 2 * p * (1 - p)
#--------------------------------------------------------------------------get A

compute_element <- function(k, l) {
  
  result <- 0
  
  for (idx in 1:nrow(genotypes)) {
    if (k == k1) {
      Gk <- genotypes$Gck1[idx]
    } else if (k == k2) {
      Gk <- genotypes$Gck2[idx]
    }
    
    if (l == k1) {
      Gl <- genotypes$Gck1[idx]
    } else if (l == k2) {
      Gl <- genotypes$Gck2[idx]
    }
    
    v1 <- genotypes$v1[idx]
    prob <- genotypes$prob[idx]
    
    result <- result + Gk * v1 * Gl * prob
  }
  return(result)
  
}

A <- matrix(0, nrow = k2, ncol = k2)

for (k in 1:k2) {
  for (l in 1:k2) {
    if ((k < k1 || l < k1) && k != l) {
      A[k, l] <- 0
    } else if (k < k1 && l < k1 && k == l) {
      A[k, l] <- Var_G * E_v1
    } else {
      A[k, l] <- compute_element(k, l)
    }
  }
}
#--------------------------------------------------------------------------get B
B_matrix <- matrix(0, nrow = k2, ncol = k2)

for (k in 1:(k2-2)) {
  B_matrix[k, k] <- Var_G * E_mu_beta2 / n
}

E_k1k1 <-(n*sum(genotypes$Gck1^2 * genotypes$mu_beta^2 * genotypes$prob)
+n*(n-1)*(sum(genotypes$Gck1 * genotypes$mu_beta * genotypes$prob))^2)
B_matrix[k1, k1] <- E_k1k1 / n^2

E_k2k2 <- (n*sum(genotypes$Gck2^2 * genotypes$mu_beta^2 * genotypes$prob)
+n*(n-1)*(sum(genotypes$Gck2 * genotypes$mu_beta * genotypes$prob))^2)
B_matrix[k2, k2] <- E_k2k2 / n^2

E_k1k2 <- (n*sum(genotypes$Gck1 * genotypes$mu_beta^2 * genotypes$Gck2 * genotypes$prob)
           +n*(n-1)*sum(genotypes$Gck1 * genotypes$mu_beta * genotypes$prob)
                   *sum(genotypes$Gck2 * genotypes$mu_beta * genotypes$prob))
B_matrix[k1, k2] <- E_k1k2/n^2
B_matrix[k2, k1] <- B_matrix[k1, k2]

B<-B_matrix
 
    c1<-rep(0,4)
    c2<-rep(0,4)
    c_a<-rep(0,4)
    
  A2<-A %*% A
  A3<-A2 %*% A
  
  c1[1] = sum(diag(A)) * n
  c1[2] = sum(A *t(A)) * n^2
  c1[3] = sum(A2 * t(A) ) * n^3
  c1[4] = sum(A2 * t(A2)) * n^4
  
  c2[1] = sum(diag(B)) * n^2
  c2[2] = 2 * sum(A * t(B)) * n^3
  c2[3] = 3 * sum(A2 * t(B)) * n^4
  c2[4] = 4 * sum(A3* t(B)) * n^5
    
    for(mm in 1:4){
      c_a[mm]<-c1[mm] + c2[mm]
    }

    #under null
    null<-lee(c1)
    quantile<-qchisq(1-alpha, df = null$l, ncp = null$delta)
    qc=(quantile-null$mux)*null$sigmaq/null$sigmax+null$muq
    #under alternative
    alt<-lee(c_a)
    temp<-(qc-alt$muq)*alt$sigmax/alt$sigmaq+alt$mux
    power[ii]<-pchisq(temp,df=alt$l,ncp=alt$delta,lower.tail = FALSE)
  }
  return(power)
}

powerD_deriveCor<-function(kk,n,alpha,p,rho,list1,list2) {
  power<-c()
  k1=kk-1
  k2=kk
  alpha0=-1
  pi_0=exp(alpha0)/(1+exp(alpha0))　
  
  for (ii in 1:25){
    beta<-c(rep(0,kk-2),list1[ii], list2[ii])
    G_value <- c(0, 1, 2)
    prob_G <- c((1 - p)^2, 2 * p * (1 - p), p^2)
    Gc <- G_value - 2 * p 
    
    genotypes <- expand.grid(Gk1 = G_value, Gk2 = G_value)
    genotypes$prob_Gk1 <- prob_G[genotypes$Gk1 + 1]
    genotypes$prob_Gk2 <- prob_G[genotypes$Gk2 + 1]
    genotypes$prob <- genotypes$prob_Gk1 * genotypes$prob_Gk2
    
    #condition on 0
    p0_0=(1-p+rho*p)^2
    p1_0=2*p*(1-rho)*(1-p+rho*p)
    p2_0=(p-rho*p)^2
    p2_0+p1_0+p0_0
    #condition on 1
    p0_1=(1-p-rho+rho*p)*(1-p+rho*p)
    p1_1=(p+rho-rho*p)*(1-p+rho*p)+(p-p*rho)*(1-p-rho+p*rho)
    p2_1=(p+rho-rho*p)*(p-p*rho)
    p0_1+p1_1+p2_1
    #condition on 2
    p0_2=(1-p-rho+rho*p)^2
    p1_2=2*(p+rho-rho*p)*(1-p-rho+p*rho)
    p2_2=(p+rho-rho*p)^2
    p0_2+p1_2+p2_2
    
    p0=(1-p)^2
    p1=2*p*(1-p)
    p2=p^2
    
    p00=p0_0*p0
    p22=p2_2*p2
    p11=p1_1*p1
    p20=p2_0*p0
    p02=p0_2*p2
    p12=p1_2*p2
    p21=p2_1*p1
    p10=p1_0*p0
    p01=p0_1*p1
    genotypes$probrho<-c(p00,p10,p20,
                         p01,p11,p21,
                         p02,p12,p22)
    
    genotypes$Gck1 <- genotypes$Gk1 - 2 * p
    genotypes$Gck2 <- genotypes$Gk2 - 2 * p
    
    sigma_prime <- function(x) {
      exp(x) / (1 + exp(x))^2
    }
    
    genotypes$eta <- beta[k1] * genotypes$Gck1 + beta[k2] * genotypes$Gck2 + alpha0
    genotypes$v1 <- sigma_prime(genotypes$eta)
    genotypes$pi_i <- exp(genotypes$eta) / (1 + exp(genotypes$eta))
    #pi_0 <- sum(genotypes$pi_i * genotypes$prob)
    genotypes$mu1<- genotypes$pi_i - pi_0
    genotypes$mu_beta <- genotypes$pi_i - pi_0
    E_v1 <- sum(genotypes$v1 * genotypes$prob)
    E_mu_beta2 <- sum(genotypes$mu_beta^2 * genotypes$prob)
    Var_G <- 2 * p * (1 - p)
    
    E_k1k1<-sum(genotypes$Gck1^2 * genotypes$v1 * genotypes$probrho)
    E_k2k2<-sum(genotypes$Gck2^2 * genotypes$v1 * genotypes$probrho)
    E_k1k2<-sum(genotypes$Gck1 * genotypes$Gck2^2 * genotypes$v1 * genotypes$probrho)
    #simulate some probabities
    set.seed(100) 
    margprob <- c(rep(p, 4))  
    bincorr <- (1 - rho) * diag(4) + rho  
    commonprob<-bincorr2commonprob(margprob, bincorr)
    sigma<-commonprob2sigma(commonprob)
    C <- rmvbin(n*1000,margprob=diag(commonprob),sigma=sigma)
    D <- rmvbin(n*1000,margprob=diag(commonprob),sigma=sigma)
    G<-C+D
    G11 <- G[, 1]
    G12 <- D[, 2]
    G13 <- D[, 3]
    G14 <- D[, 4]
    
    # P(G13, G14 | G11)
    joint_con_prob1 <- function(G11_value) {
      subset_G <- G[G[,1] == G11_value, ]
      joint_con_prob <- matrix(0, nrow = 3, ncol = 3)
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          count_G13_G14 <- sum(subset_G[,3] == G13_value & subset_G[,4] == G14_value)
          joint_con_prob[G13_value+1, G14_value+1] <- count_G13_G14 / nrow(subset_G)
        }
      }
      
      return(joint_con_prob)
    }
    
    #  P(G13, G14 | G11, G12)
    joint_con_prob2 <- function(G11_value, G12_value) {
      subset_G <- G[G[,1] == G11_value & G[,2] == G12_value, ]
      joint_con_prob <- matrix(0, nrow = 3, ncol = 3)
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          count_G13_G14 <- sum(subset_G[,3] == G13_value & subset_G[,4] == G14_value)
          joint_con_prob[G13_value+1, G14_value+1] <- count_G13_G14 / nrow(subset_G)
        }
      }
      
      return(joint_con_prob)
    }
    
    # E(v1|G11,G12)/E(v1|G11)
    inner_e0 <- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12) or P(G13, G14 | G11)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          v1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))^2
          inner_e <- inner_e + v1 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    # E(G13*v1*G11|G11)
    inner_e13 <- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          v1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))^2
          inner_e <- inner_e + (G13_value-2*p)*v1 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    # E(G14*v1*G11|G11)
    inner_e14 <- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          v1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))^2
          inner_e <- inner_e + (G14_value-2*p)*v1 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    
    # E(G11*G11*v1)
    outer_e11<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(v1 | G11)
        inner_e <- inner_e0(joint_con_prob)
        # E(G11*G11*v1)
        outer_e <- outer_e + (Gi_val-2*p)^2 * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    # E(G11*G12*v1)
    outer_e12<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        for (Gj_val in 0:2) {
          # P(G11, G12)
          prob_Gi_Gj <- genotypes$probrho[genotypes$Gk1==Gi_val & genotypes$Gk2==Gj_val]
          #p(G13,G14|G11,G12)
          joint_con_prob <- joint_con_prob2(Gi_val, Gj_val)
          #  E(v1 | G11, G12)
          inner_e <- inner_e0(joint_con_prob)
          # E(G11*G12*v1)
          outer_e <- outer_e + (Gi_val-2*p) * (Gj_val-2*p)  * prob_Gi_Gj * inner_e
        }
      }
      
      return(outer_e)
    }
    
    # E(G11*G13*v1)
    outer_e13<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]  
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(G13*v1 | G11)
        inner_e <- inner_e13(joint_con_prob)
        # E(G11*G13*v1)
        outer_e <- outer_e + (Gi_val-2*p)  * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    # E(G11*G14*v1)
    outer_e14<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]  
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(G14*v1 | G11)
        inner_e <- inner_e14(joint_con_prob)
        # E(G11*G14*v1)
        outer_e <- outer_e + (Gi_val-2*p)  * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    
    generate_matrix_X <- function(a, b, c, d, e, f, g) {
      # Initialize a 4x4 matrix with zeros
      X <- matrix(0, nrow = kk, ncol = kk)
      
      # Fill in the diagonal elements based on the conditions
      for (k in 1:k2) {
        if (k < k1) {
          X[k, k] <- a  # For k = 1, 2: X[k, k] = a
        } else if (k == k1) {
          X[k, k] <- b  # For k = 3: X[k, k] = b
        } else if (k == k2) {
          X[k, k] <- c  # For k = 4: X[k, k] = c
        }
      }
      
      # Fill in the off-diagonal elements
      
      for (k in 1:k2) {
        for (l in 1:k2) {
          if (k != l) {
            if (k < k1 && l < k1) {
              X[k, l] <- d  # For k < 3 and l < 3: X[k, l] = d
            } else if ( (k == k1 & l<k2) || (l == k1 && k<k2)) {
              X[k, l] <- e  # For k = 3 or l = 3: X[k, l] = e
            } else if (k == k2 || l == k2) {
              if ((k == k2 && l == k1) || (l == k2 && k == k1)) {
                X[k, l] <- g  # Special case: (k = 4, l = 3) or (k = 3, l = 4): X[k, l] = g
              } else {
                X[k, l] <- f  # For k = 4 or l = 4: X[k, l] = f
              }
            }
          }
        }
      }
      
      return(X)
    }
    
    
    a <- outer_e11()  # Diagonal element when k < 3
    b <- E_k1k1  # Diagonal element when k = 3
    c <- E_k2k2  # Diagonal element when k = 4
    d <- outer_e12()  # Off-diagonal element when k < 3 and l < 3
    e <- outer_e13()   # Off-diagonal element when k = 3 or l = 3
    f <- outer_e14()   # Off-diagonal element when k = 4 or l = 4
    g <- E_k1k2   # Special case for (k = 4, l = 3) or (k = 3, l = 4)
    
    A <- generate_matrix_X(a, b, c, d, e, f, g)
    
    #---------------------------------------------------------------------------------------------------------------get B
    # E(mu1|G11,G12)/E(v1|G11)
    inner_e0<- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12) or P(G13, G14 | G11)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          pi_1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))
          mu1=pi_1-pi_0
          inner_e <- inner_e + mu1 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    
    # E(mu1^2|G11,G12)/E(v1|G11)
    inner_e0sq <- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12) or P(G13, G14 | G11)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          pi_1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))
          mu1=pi_1-pi_0
          inner_e <- inner_e + mu1^2 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    
    
    # E(G13*mu1^2|G11)
    inner_e13 <- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          pi_1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))
          mu1=pi_1-pi_0
          inner_e <- inner_e + (G13_value-2*p)*mu1^2 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    
    
    # E(G14*mu1^2|G11)
    inner_e14<- function(joint_con_prob) {
      inner_e <- 0
      for (G13_value in 0:2) {
        for (G14_value in 0:2) {
          # P(G13, G14 | G11, G12)
          prob_G13_G14 <- joint_con_prob[G13_value+1, G14_value+1]
          pi_1 <-   exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]) / (1 + exp(alpha0 + G13_value * beta[k1] + G14_value * beta[k2]))
          mu1=pi_1-pi_0
          inner_e <- inner_e + (G14_value-2*p)*mu1^2 * prob_G13_G14
          
        }
      }
      return(inner_e)
    }
    
    # E(G11^2*mu1^2)
    outer_e11sq<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(mu1^2 | G11)
        inner_e <- inner_e0sq(joint_con_prob)
        # E(G11*G11*v1)
        outer_e <- outer_e + (Gi_val-2*p)^2 * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    # E(G11*mu1)
    outer_e11<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(mu | G11)
        inner_e <- inner_e0(joint_con_prob)
        # E(G11*mu1)
        outer_e <- outer_e + (Gi_val-2*p) * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    # E(G11*G12*mu1^2)
    outer_e12<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        for (Gj_val in 0:2) {
          # P(G11, G12)
          prob_Gi_Gj <- genotypes$probrho[genotypes$Gk1==Gi_val & genotypes$Gk2==Gj_val]
          #p(G13,G14|G11,G12)
          joint_con_prob <- joint_con_prob2(Gi_val, Gj_val)
          #  E(mu1^2| G11, G12)
          inner_e <- inner_e0sq(joint_con_prob)
          # E(G11*G12*mu1^2)
          outer_e <- outer_e + (Gi_val-2*p) * (Gj_val-2*p)  * prob_Gi_Gj * inner_e
        }
      }
      
      return(outer_e)
    }
    
    
    # E(G11*G13*mu1^2)
    outer_e13<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]  
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(G13*mu1^2 | G11)
        inner_e <- inner_e13(joint_con_prob)
        # E(G11*G13*mu1^2)
        outer_e <- outer_e + (Gi_val-2*p)  * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    
    # E(G11*G14*mu1^2)
    outer_e14<- function() {
      outer_e <- 0
      for (Gi_val in 0:2) {
        # P(G11)
        prob_Gi <-prob_G[Gi_val+1]  
        #p(G13,G14|G11)
        joint_con_prob <- joint_con_prob1(Gi_val)
        #  E(G14*mu1^2 | G11)
        inner_e <- inner_e14(joint_con_prob)
        # E(G11*G14*mu1^2)
        outer_e <- outer_e + (Gi_val-2*p)  * prob_Gi * inner_e
        
      }
      
      return(outer_e)
    }
    
    a<-outer_e11sq()
    b<-outer_e11()
    c<-sum(genotypes$Gck1^2 * genotypes$mu1^2 * genotypes$probrho)
    d<-sum(genotypes$Gck1 * genotypes$mu1 * genotypes$probrho)
    e<-sum(genotypes$Gck2^2 * genotypes$mu1^2 * genotypes$probrho)
    f<-sum(genotypes$Gck2 * genotypes$mu1 * genotypes$probrho)
    g<-outer_e12()
    h<-outer_e13()
    i<-outer_e14()
    j<-sum(genotypes$Gck1 * genotypes$Gck2^2 * genotypes$mu1^2 * genotypes$probrho)
    
    aa<-n*a+n*(n-1)*b^2
    bb<-n*c+n*(n-1)*d^2
    cc<-n*e+n*(n-1)*f^2
    dd<-n*g+n*(n-1)*b^2
    ee<-n*h+n*(n-1)*d*b
    ff<-n*i+n*(n-1)*f*b
    gg<-n*j+n*(n-1)*f*d
    
    generate_matrix_Y <- function() {
      # Initialize a 4x4 matrix with zeros
      X <- matrix(0, nrow = kk, ncol = kk)
      
      # Fill in the diagonal elements based on the conditions
      for (k in 1:k2) {
        if (k < k1) {
          X[k, k] <- aa  # For k = 1, 2: X[k, k] = a
        } else if (k == k1) {
          X[k, k] <- bb # For k = 3: X[k, k] = b
        } else if (k == k2) {
          X[k, k] <- cc  # For k = 4: X[k, k] = c
        }
      }
      
      # Fill in the off-diagonal elements
      
      for (k in 1:k2) {
        for (l in 1:k2) {
          if (k != l) {
            if (k < k1 && l < k1) {
              X[k, l] <- dd  # For k < 3 and l < 3: X[k, l] = d
            } else if ( (k == k1 & l<k2) || (l == k1 && k<k2)) {
              X[k, l] <- ee  # For k = 3 or l = 3: X[k, l] = e
            } else if (k == k2 || l == k2) {
              if ((k == k2 && l == k1) || (l == k2 && k == k1)) {
                X[k, l] <- gg  # Special case: (k = 4, l = 3) or (k = 3, l = 4): X[k, l] = g
              } else {
                X[k, l] <- ff  # For k = 4 or l = 4: X[k, l] = f
              }
            }
          }
        }
      }
      
      return(X)
    }
    
    
    B <- generate_matrix_Y()/n^2
    
    suml=sumld=cnull=calt<- numeric(4)  
    
    c1<-rep(0,4)
    c2<-rep(0,4)
    c_a<-rep(0,4)
    
    A2<-A %*% A
    A3<-A2 %*% A
    
    
    c1[1] = sum(diag(A)) * n
    c1[2] = sum(A *t(A)) * n^2
    c1[3] = sum(A2 * t(A) ) * n^3
    c1[4] = sum(A2 * t(A2)) * n^4
    
    c2[1] = sum(diag(B)) * n^2
    c2[2] = 2 * sum(A * t(B)) * n^3
    c2[3] = 3 * sum(A2 * t(B)) * n^4
    c2[4] = 4 * sum(A3* t(B)) * n^5
    
    for(i in 1:4){
      c_a[i]<-c1[i] + c2[i]
    }
    #under null
    null<-lee(c1)
    q0<-qchisq(1-alpha, df = null$l, ncp = null$delta)
    qc=(q0-null$mux)*null$sigmaq/null$sigmax+null$muq
    #under alternative
    alt<-lee(c_a)
    temp<-(qc-alt$muq)*alt$sigmax/alt$sigmaq+alt$mux
    power[ii]<-pchisq(temp,df=alt$l,ncp=alt$delta,lower.tail = FALSE)
  }
  return(power)
}



```

## Continuous outcome, 50 uncorrelated SNPs, MAF=0.01, 0.1<=$\beta$<=0.9
```{r linear_0.01_uncor,echo=FALSE,warning=FALSE}

# --- Calculation code remains the same ---
powerDerived<-powerC_derive(k=50,n=2000,alpha=0.05,p=0.01,list1=beta1list1,list2=beta2list1)
#result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/snpC_1.Rdata"))
result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/new/snpC_1000_1.Rdata"))

powerE2 <- sapply(result, function(x) x$powerE2)
powerCombined <- sapply(result, function(x) x$powerCombined)
powerSeparated <- sapply(result, function(x) x$powerSeparated)

df<-as.data.frame(cbind(as.vector(beta1list1),as.vector(beta2list1),powerSeparated,powerCombined,powerDerived,powerE2))
colnames(df)<-c("beta1","beta2","power1","power2","power3","power4")
power1<-cbind(df[,1:3],rep("Sim,True",25))
power2<-cbind(df[,c(1,2,4)],rep("Sim,Mis",25))
power3<-cbind(df[,c(1,2,5)],rep("Analytic,True",25))
power4<-cbind(df[,c(1,2,6)],rep("Analytic,Mis",25))
colnames(power1)[3:4]<-c("power","group")
colnames(power2)[3:4]<-c("power","group")
colnames(power3)[3:4]<-c("power","group")
colnames(power4)[3:4]<-c("power","group")
dfnew1 <- rbind(power1, power2, power3, power4) # Use dfnew1 to avoid name clash later

beta2<-as.vector(c(0.1,0.25,0.5,0.75))
dfsub<-list()
plots1 <- list() # Store plots in a list
line_types <- c("solid", "solid", "dashed", "dashed")

for (i in 1:4){
  dfsub[[i]] <- dfnew1[dfnew1$beta2==beta2[i], ]
  plots1[[i]] <- ggplot(dfsub[[i]], aes(x = beta1, y = power, group=group)) +
          geom_point(aes(color=group,shape=group)) +
          geom_line(aes(color=group,linetype=group)) +
          scale_linetype_manual(values = line_types) +
          labs(title = bquote(beta[50] == .(beta2[i])),
               x = bquote("\u03B2"[49]),
               y = "Power",
               color = "", shape = "", linetype = "") +
          mytheme +
         scale_y_continuous(limits = c(0, 1))}

# Combine the 4 panels for Figure 1 with labels a, b, c, d
fig1_panels <- ggarrange(plotlist = plots1, ncol = 4, nrow = 1, labels = c("A", "B", "C", "D"))

# Don't print yet, just store the combined panels
# print(fig1_panels)
```

## Continuous outcome, 50 correlated SNPs,MAF=0.05, rho=0.15, 0.1<=<span class="math-inline">\\beta</span><=0.5
```{r linear_0.05_cor,echo=FALSE, warning=FALSE,cache=FALSE}

# --- Calculation code remains the same ---
powerDerived<-powerC_deriveCor(k=50,n=2000,alpha=0.05,p=0.05, rho=0.15,list1=beta1list11,list2=beta2list11)
#result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/snpCcor_0.1_0.5_1.Rdata"))
result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/new/snpCcor_1000_1.Rdata"))

powerE2 <- sapply(result, function(x) x$powerE2)
powerCombined <- sapply(result, function(x) x$powerCombined)
powerSeparated <- sapply(result, function(x) x$powerSeparated)

df<-as.data.frame(cbind(as.vector(beta1list11),as.vector(beta2list11),powerSeparated,powerCombined,powerDerived,powerE2))
colnames(df)<-c("beta1","beta2","power1","power2","power3","power4")
power1<-cbind(df[,1:3],rep("Sim,True",25))
power2<-cbind(df[,c(1,2,4)],rep("Sim,Mis",25))
power3<-cbind(df[,c(1,2,5)],rep("Analytic,True",25))
power4<-cbind(df[,c(1,2,6)],rep("Analytic,Mis",25))
colnames(power1)[3:4]<-c("power","group")
colnames(power2)[3:4]<-c("power","group")
colnames(power3)[3:4]<-c("power","group")
colnames(power4)[3:4]<-c("power","group")
dfnew2 <- rbind(power1, power2, power3, power4) # Use dfnew2

beta2<-as.vector(c(0.1,0.2,0.3,0.4))
dfsub<-list()
plots2 <- list() # Store plots in a list
line_types <- c("solid", "solid", "dashed", "dashed")

for (i in 1:4){
  dfsub[[i]] <- dfnew2[dfnew2$beta2==beta2[i], ]
  plots2[[i]] <- ggplot(dfsub[[i]], aes(x = beta1, y = power, group=group)) +
          geom_point(aes(color=group,shape=group)) +
          geom_line(aes(color=group,linetype=group)) +
          scale_linetype_manual(values = line_types) +
          labs(title = bquote(beta[50] == .(beta2[i])),
               x = bquote("\u03B2"[49]),
               y = "Power",
               color = "", shape = "", linetype = "") +
          mytheme +
         scale_y_continuous(limits = c(0, 1))}

# Combine the 4 panels for Figure 2 with labels e, f, g, h
fig2_panels <- ggarrange(plotlist = plots2, ncol = 4, nrow = 1, labels = c("E", "F", "G", "H"))

# Don't print yet
# fig2_panels
```

## Binary outcome, 50 uncorrelated SNPs, MAF=0.01, 0.1<=$\beta$<=0.9
```{r logistic_0.01_uncor,echo=FALSE,warning=FALSE,cache=TRUE}

# --- Calculation code remains the same ---
powerDerived<-powerD_derive(kk=50,n=2000,alpha=0.05,p=0.01,list1=beta1list1,list2=beta2list1)
result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/new/snpD_10000_1.Rdata"))
powerE2 <- sapply(result, function(x) x$powerE2)
powerCombined <- sapply(result, function(x) x$powerCombined)
powerSeparated <- sapply(result, function(x) x$powerSeparated)

df<-as.data.frame(cbind(as.vector(beta1list1),as.vector(beta2list1),powerSeparated,powerCombined,powerDerived,powerE2))
colnames(df)<-c("beta1","beta2","power1","power2","power3","power4")
power1<-cbind(df[,1:3],rep("Sim,True",25))
power2<-cbind(df[,c(1,2,4)],rep("Sim,Mis",25))
power3<-cbind(df[,c(1,2,5)],rep("Analytic,True",25))
power4<-cbind(df[,c(1,2,6)],rep("Analytic,Mis",25))
colnames(power1)[3:4]<-c("power","group")
colnames(power2)[3:4]<-c("power","group")
colnames(power3)[3:4]<-c("power","group")
colnames(power4)[3:4]<-c("power","group")
dfnew3 <- rbind(power1, power2, power3, power4) # Use dfnew3

beta2<-as.vector(c(0.1,0.25,0.5,0.75))
dfsub<-list()
plots3 <- list() # Store plots in a list
line_types <- c("solid", "solid", "dashed", "dashed")
for (i in 1:4){
  dfsub[[i]] <- dfnew3[dfnew3$beta2==beta2[i], ]
  plots3[[i]] <- ggplot(dfsub[[i]], aes(x = beta1, y = power, group=group)) +
          geom_point(aes(color=group,shape=group)) +
          geom_line(aes(color=group,linetype=group)) +
          scale_linetype_manual(values = line_types) +
          labs(title = bquote(beta[50] == .(beta2[i])),
               x = bquote("\u03B2"[49]),
               y = "Power",
               color = "", shape = "", linetype = "") +
          mytheme +
         scale_y_continuous(limits = c(0, 0.6))
}

# Combine the 4 panels for Figure 3 with labels a, b, c, d
fig3_panels <- ggarrange(plotlist = plots3, ncol = 4, nrow = 1, labels = c("A", "B", "C", "D"))

# Don't print yet
# fig3_panels
```

## Binary outcome, 50 correlated SNPs,MAF=0.05, rho=0.15, 0.1<=<span class="math-inline">\\beta</span><=0.9
```{r logistic_0.05_cor,echo=FALSE, cache=FALSE, warning=FALSE}

# --- Calculation code remains the same ---
#powerDerived<-powerD_deriveCor(kk=50,n=2000,alpha=0.05,p=0.05, rho=0.15,list1=beta1list1,list2=beta2list1)
 powerDerived<-c(0.81411394, 0.74636639, 0.72838540, 0.80309541, 0.86467059,
                  0.59477499, 0.49388130, 0.45457005, 0.55383859, 0.65478742,
                0.39450203, 0.26881186, 0.16564075, 0.18925041, 0.26180040,
                 0.46681149, 0.30707499, 0.13014782, 0.06845541, 0.07898002,
                 0.57999967, 0.41084567, 0.18412141, 0.07220962, 0.05257711)
result<-get(load("//Users/nkui/Library/CloudStorage/OneDrive-InsideMDAnderson(2)/SKATsimulation/output/new/snpDcor_1.Rdata"))
powerE2 <- sapply(result, function(x) x$powerE2)
powerCombined <- sapply(result, function(x) x$powerCombined)
powerSeparated <- sapply(result, function(x) x$powerSeparated)

df<-as.data.frame(cbind(as.vector(beta1list1),as.vector(beta2list1),powerSeparated,powerCombined,powerDerived,powerE2))
colnames(df)<-c("beta1","beta2","power1","power2","power3","power4")
power1<-cbind(df[,1:3],rep("Sim,True",25))
power2<-cbind(df[,c(1,2,4)],rep("Sim,Mis",25))
power3<-cbind(df[,c(1,2,5)],rep("Analytic,True",25))
power4<-cbind(df[,c(1,2,6)],rep("Analytic,Mis",25))
colnames(power1)[3:4]<-c("power","group")
colnames(power2)[3:4]<-c("power","group")
colnames(power3)[3:4]<-c("power","group")
colnames(power4)[3:4]<-c("power","group")
dfnew4 <- rbind(power1, power2, power3, power4) # Use dfnew4

beta2<-as.vector(c(0.1,0.25,0.5,0.75))
dfsub<-list()
plots4 <- list() # Store plots in a list
line_types <- c("solid", "solid", "dashed", "dashed")

for (i in 1:4){
  dfsub[[i]] <- dfnew4[dfnew4$beta2==beta2[i], ]
  plots4[[i]] <- ggplot(dfsub[[i]], aes(x = beta1, y = power, group=group)) +
          geom_point(aes(color=group,shape=group)) +
          geom_line(aes(color=group,linetype=group)) +
          scale_linetype_manual(values = line_types) +
          labs(title = bquote(beta[50] == .(beta2[i])),
               x = bquote("\u03B2"[49]),
               y = "Power",
               color = "", shape = "", linetype = "") +
          mytheme +
         scale_y_continuous(limits = c(0, 0.7))}

# Combine the 4 panels for Figure 4 with labels e, f, g, h
fig4_panels <- ggarrange(plotlist = plots4, ncol = 4, nrow = 1, labels = c("E", "F", "G", "H"))

# Don't print yet
# fig4_panels
```

## Combine Figures
```{r combine,echo=FALSE, cache=FALSE, warning=FALSE}
# Create a dummy plot using data from any of the chunks (e.g., dfnew1)
# to extract the legend
dummy_plot <- ggplot(dfnew1, aes(x = beta1, y = power,
                                color = group,
                                linetype = group,
                                shape = group)) +
  geom_point() +
  geom_line() +
  scale_linetype_manual(values = c("solid", "solid", "dashed", "dashed")) +
  theme(legend.position = "bottom") +
  labs(color = NULL, linetype = NULL, shape = NULL) # Remove legend titles

# Extract the legend
legend <- cowplot::get_legend(dummy_plot)

# --- Create Final Figure 1 (Combining original Fig 1 & 2) ---
# Arrange the panels of fig1 and fig2 vertically
combined_fig_1_2 <- ggarrange(
  fig1_panels, fig2_panels,
  nrow = 2, ncol = 1
  # No common legend here, add it below
)

# Add the shared legend to the bottom
final_plot_1_2 <- ggarrange(
  combined_fig_1_2, legend,
  nrow = 2, ncol = 1,
  heights = c(10, 1) # Adjust ratio for plot vs legend as needed
)

# Print the first final figure
print(final_plot_1_2)


# --- Create Final Figure 2 (Combining original Fig 3 & 4) ---
# Arrange the panels of fig3 and fig4 vertically
combined_fig_3_4 <- ggarrange(
  fig3_panels, fig4_panels,
  nrow = 2, ncol = 1
  # No common legend here, add it below
)

# Add the shared legend to the bottom
final_plot_3_4 <- ggarrange(
  combined_fig_3_4, legend,
  nrow = 2, ncol = 1,
  heights = c(10, 1) # Adjust ratio for plot vs legend as needed
)

# Print the second final figure
print(final_plot_3_4)
```